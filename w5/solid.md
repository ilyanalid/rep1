Вот как расшифровывается акроним **SOLID**:

- **S: Single Responsibility Principle** (Принцип единственной ответственности).
- **O: Open-Closed Principle** (Принцип открытости-закрытости).
- **L: Liskov Substitution Principle** (Принцип подстановки Барбары Лисков).
- **I: Interface Segregation Principle** (Принцип разделения интерфейса).
- **D: Dependency Inversion Principle** (Принцип инверсии зависимостей).

**Single responsibility.**

Класс должен быть ответственен лишь за что-то *одно*. Если класс отвечает за решение нескольких задач, его подсистемы, реализующие решение этих задач, оказываются связанными друг с другом. Изменения в одной такой подсистеме ведут к изменениям в другой.
Обратите внимание на то, что этот принцип применим не только к классам, но и к компонентам программного обеспечения в более широком смысле.

Если изменится порядок работы с хранилищем данных, используемым приложением, то придётся вносить изменения во все классы, работающие с хранилищем. Такая архитектура не отличается гибкостью, изменения одних подсистем затрагивают другие, что напоминает эффект домино.

**Open-Closed Principle.**

Принцип открытости/закрытости означает, что программные сущности должны быть:

- открыты для расширения: означает, что поведение сущности может быть расширено путём создания новых типов сущностей.
- закрыты для изменения: в результате расширения поведения сущности, не должны вноситься изменения в код, который эту сущность использует.

Это особенно значимо в производственной среде, когда изменения в исходном коде потребуют проведение пересмотра кода, модульного тестирования и других подобных процедур, чтобы получить право на использование его в программном продукте. Код, подчиняющийся данному принципу, не изменяется при расширении и поэтому не требует таких трудозатрат.

**Liskov Substitution Principle.**

*Цель* этого принципа заключаются в том, чтобы классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, **не нарушая** работу программы. Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается.

Этот принцип является важнейшим критерием для оценки качества принимаемых решений при построении иерархий наследования. 

Сформулировать его можно в виде простого правила:

`тип S будет подтипом Т тогда и только тогда, когда каждому объекту oS типа S соответствует некий объект oT типа T таким образом, что для всех программ P, реализованных в терминах T, поведение P не будет меняться, если oT заменить на oS.`

Более простыми словами можно сказать, что поведение наследующих классов не должно противоречить поведению, заданному базовым классом, то есть поведение наследующих классов должно быть ожидаемым для кода, использующего переменную базового типа.